#### 一、一条 SQL 查询语句是如何执行的

 ![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png) 

1. ##### 连接器

   建立连接、获取权限、维持管理连接

   ```bash
   mysql -h$ip -P$port -u$user -p
   ```

   过程：TCP 握手->身份认证->权限验证

   - 过程中的权限认证将一直保留，即使中途管理员修改了用户权限，也无法改变，需要重新登陆使其生效

   - 完成连接后如果没有后续操作，连接处于空闲状态，控制台show processlist可以看到连接状态

   - 空闲状态保留时间默认值是 8 小时

     ```mysql
     show variables like 'wait_timeout';
     ```

   - 长连接持续有请求使用同一连接；短连接执行完几次断开下次查询重新建立

   - 建立连接复杂，尽量使用长连接；长连接空闲也会消耗占用内存；如何保持连接，8小时内发送查询语句

   - mysql 在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开时释放，累计会导致内存占用过大，被系统强杀

   - 解决长连接内存占用问题：

     - 定期断开；使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 
     - mysql 5.7版本以上，可以每次执行完比较大的操作，通过执行 mysql_reset_connection 来重新初始化连接资源（这个过程不需要重连操作和权限认证）

2. ##### 查询缓存

   - MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。

   - MySQL 提供了 “ 按需使用 ” 的方式。可以将参数 query_cache_type 设置成 DEMAND，对于默认的 SQL 语句都不使用查询缓存。对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： 

     ```sql
     mysql> select SQL_CACHE * from T where ID=10；
     ```

   - 不建议使用查询缓存

     - 缓存需要语句完全相等，包括参数
     - 表更新后就会失效 因此，只有在表更新频率不高，查询语句完全一致的情况下，可以手动开启缓存，其他一律关闭
     - mysql8之后，取消了缓存功能

   -   问题：缓存的释放是和连接绑定吗？

3. ##### 分析器

   - 词法分析
   - 语法分析

4. ##### 优化器

   - 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序 
   - 原则是：尽可能少的扫描数据库行记录

5. ##### 执行器



#### 二、一条 SQL 更新语句是如何执行的

1. ##### WAL技术（Write-Ahead Logging）

   先写日志，再写磁盘 （问题：是否会出现更新不同步，读错误现象）

2. ##### redo log （重做日志）

   - 同样写磁盘，顺序 IO； 更新操作是随机 IO，多出一个寻址时间
   - 大小固定，可以循环写；如果超出，需要将一部分写入擦除
   - 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 

3. ##### binlog （归档日志）

   ![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

4. ##### 两阶段提交

   - 保证数据库的一致性，必须要保证2份日志一致，使用的2阶段式提交；其实感觉像事务，不是成功就是失败，不能让中间环节出现，也就是一个成功，一个失败 

#### 三、事务隔离

1. ##### ACID：原子性、一致性、隔离性、持久性

2. ##### 事务隔离级别

   - 读未提交
   - 读提交
   - 可重复读
   - 串行化

3. ##### 关于视图

   - RC级别下，MVCC视图会在每一个语句前创建一个，所以在RC级别下，一个事务是可以看到另外一个事务已经提交的内容，因为它在每一次查询之前都会重新给予最新的数据创建一个新的MVCC视图。 RR级别下，MVCC视图实在开始事务的时候就创建好了，这个视图会一直使用，直到该事务结束。 这里要注意不同的隔离级别他们的一致性事务视图创建的时间点是不同的。 RU：没有视图的概念，直接返回最小行数据。 RC：在每一行SQL语句执行的时候创建。 RR：在事务启动的时候创建。 Serial：通过锁来实现数据访问，没有视图的概念。 

4. ##### 查看

   - mysql隔离级别：可重复读；其他：读提交

   ```sql
   
   mysql> show variables like 'transaction_isolation';
   
   +-----------------------+----------------+
   
   | Variable_name | Value |
   
   +-----------------------+----------------+
   
   | transaction_isolation | READ-COMMITTED |
   
   +-----------------------+----------------+
   ```

5. ##### 事务隔离的实现

6. ##### 事物的启动方式

#### 四、索引

1. ##### 索引的常见模型

   - 哈希表
     - 适合插入及等值查询，不适合范围查找
   - 有序数组
     - 适合等值查询及范围查询，不适合插入操作
   - 搜索树
     - 数据库存储使用b+树 而不是二叉树，因为二叉树树高过高，每次查询都需要访问过多节点，即访问数据块过多，而从磁盘随机读取数据块过于耗时。 

2. ##### InnoDB 的索引模型

   - InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。 
   - 索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

3. ##### 索引维护

   

4. ##### 总结

   - 索引的作用：提高数据查询效率
   - 常见索引模型：哈希表、有序数组、搜索树
   - 哈希表：键 - 值(key - value)。
   - 哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
   - 哈希冲突的处理办法：链表
   - 哈希表适用场景：只有等值查询的场景
   - 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
   - 有序数组查询效率高，更新效率低
   - 有序数组的适用场景：静态存储引擎。
   - 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
   - 二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
   - 数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
   - InnoDB中的索引模型：B+Tree
   - 索引类型：主键索引、非主键索引
   - 主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
   - 主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
   - 一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
   - 从性能和存储空间方面考量，自增主键往往是更合理的选择。 